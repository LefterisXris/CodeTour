{
  "id": "c9d3e3e7-194d-4124-8ccc-cea7a2c65668",
  "tourFile": "projectIntroduction-virtualAssistant.tour",
  "title": "Virtual Onboarding Assistant",
  "description": "A New Tour",
  "steps": [
    {
      "title": "Getting Started",
      "description": "# Getting Started\n\n## Info\nThis Tour contains Steps in a specific order providing information, suggestions, tasks and more resources in order to assist someone onboard to any project.\n\nCompleting all of them, will provide a brief understanding of any project.\n\n\n## Purpose\nThe purpose of this Tour is to indicate the correct ordered Steps of approaching any project, in order to utilize your onboarding experience.\n\nRead the description of each Step, and complete the related tasks that mentioned.\n\n\n## How to use this Tour\n\nFor each Step,\n- Read its description\n- Understand its context and its purpose\n- Complete its **Tasks** (you can use the ckeckboxed for your convenience, but they are not persisted)\n- Review the the **Takeways** list to make sure you are ready to proceed to the next Step\n\n**Note**: There are no technical details on this Tour. There are only the steps to be followed with suggestions for what to check and where to look for more info.\n\n\n## Extra\n\n- **Tip 1**: Play with this Tour as many times as you want, on your own pace, try to complete all the tasks, and collect question or code parts for which you need further elaboration.\n\n- **Tip 2**: Keep Step\u0027s dialog open while doing the related tasks. Having it on a separate Screen is also a good idea.\n\n- **Tip 3**: You can adjust the font-size of Step\u0027s Description by using the *more* options button (3 dots,  top right) and then **Adjust Font Size..**"
    },
    {
      "title": "README",
      "description": "# README\n\n## Tasks\n\n1. [ ] Read the whole README file\n2. [ ] Find the purpose of the project\n3. [ ] List the Stack (tools and technologies)\n\n\n## Why?\nAlways start by reading the README file. And read it all. It will take you 5 minutes at most! \nHowever, you will get an overview of the Application (what is it about, what it does, what tools are being used, structure, further info etc). \nThere is no need to dive into any link or any specific part of the README. \nYou should however be aware of what information is included there, so in case you need it you will know where to find it, so itâ€™s something like indexing (contents).\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Application Overview\n- [ ] Content and Resources Indexing"
    },
    {
      "title": "Stack Overview",
      "description": "# Stack Overview\n\n## Tasks\n\n1. [ ] Find project dependencies. Depending on your project, check the **pom.xml**, **build.gradle**, **package.json**, **requirements.txt** etc\n2. [ ] Identify the Layers\n    - Locate, if exists, the persistence layer (db)\n    - Locate any exposed API (Rest, messaging, cmd)\n    - Locate the business logic (Service layer)?\n3. [ ] Take a quick look if any of the following are present\n    - DevOps automation files (actions, pipelines, jenkinsfiles)\n    - Environment files (dockerfiles, app.properties etc)\n\n\n## Why?\nBeing aware of the dependencies of your project can be very helpful for undestanding the project\u0027s logic before reading the code.\nIf you are not aware of a dependency, a quick Google search would provide a brief explanation.\n\n\nExample if you see **NgRx** as a dependency on an **package.json** file a quick Google search would tell you that NgRx is being used for State management on Angular applications and this is very useful to know beforehand.\n\n\nExplore the Layers of the application. What is the underlying db? Is there any API exposed? Rest API (blocking), Message brokers (async). Can you locate any business logic (no need to dive into yet)? Is there any security configuration, or LDAP login? Identifying the layers of an application is important because you will start understanding its structure.\n\n\nEnvironment and DevOps files. Any automation file helps you understand what is automated and when/where it runs. In addition, the environment related files, like a dockerfile can reveal to you how the project is setup on a new environment (e.g. OS, package managers, utilities, frameworks etc). Again, don\u0027t dive into. Just identify what exists on the project.\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Project Dependencies\n- [ ] Application Layers (db, APIs, Service, Security etc)\n- [ ] Environment and DevOps files"
    },
    {
      "title": "Packages/Components",
      "description": "# Packages/Components\n\n## Tasks\n\n1. [ ] Explore non-source files (directories other than **src**)\n2. [ ] Explore **src** directory\n3. [ ] Try to understand the *grouping* logic e.g. **packages**, **modules** etc\n\n\n## Why?\n**Explore\u003d\u003dRead Files Names**. This step sounds a bit boring, but it may turned into an easter egg for you.\n\n\nStart exploring the project\u0027s File structure. Typically, the souce code would be under **src** directory. Before opening src, check if there any other directories that are used by the application.\nThen, start expanding the **src** directory and walkthrough all the packages recursively. There is no need to open any file. **Just read their names**.\n\n\nThis might reveal you some naming conventions, part of the structure or the grouping of files (modules/packages) and it also can be used as an index for later on.\n\n\nTip: **resources** directory (or **assets**) usually contains important data files for bundling, internationalization, images, application properties etc. Make sure you check them.\n\n\nAgain, you don\u0027t need to open the files, not yet! Just read their names and if the naming strategy is good you will definitely get an easter egg!\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Project Files Structure\n- [ ] Naming, Packaging Conventions\n- [ ] Indexing\n- [ ] Resources"
    },
    {
      "title": "Run the Application",
      "description": "# Run the Application\n\n## Tasks\n\n1. [ ] Install any external dependency that might be required\n2. [ ] Run tests locally (if exist, and if feasible)\n3. [ ] Look for the entry point of the Application\n4. [ ] Run the Application\n\n\n## Why?\nSo at this point, you have identified what is the project\u0027s purpose with some basic functionality, what tools it uses and how it is structured without having dived into the code.\n\n\nThus, now you should try to run the application. You should be able to run the application locally, because otherwise you won\u0027t not be able to do any development or debugging. So make sure that you are able to run it.\nTo do that, first start by making sure your local environment is correctly setup. There might be some **external** dependencies that you may need to install. For example, a backend project might need a local installation of a Relational database, for development and debugging purposes.\n\n\nNext, if applicable to your project, try running the available tests. Typically **unit** tests and some **feature** tests should be available. So run them to verify they pass.\n\n\nNext, if you have read carefully the file names of the application, you should be able to locate the entry quickly. Do so, or otherwise try to find it.\nOnce you find it, try running the application and check whether it successfully launches.\n\n\nThis step is important because you might discover that your setup is not correct, or a dependency/installation might be missing from your environment, or you may have forked or cloned the wrong branch or the branch itself could be already broken. So ensure that everything works fine.\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Correct Environment\n- [ ] Tests Passing (locally)\n- [ ] Application\u0027s Entry Point\n- [ ] Verified Application State"
    },
    {
      "title": "Discover Features",
      "description": "# Discover Features\n\n## Tasks\n\n1. [ ] Play around with the application\n2. [ ] If a UI is available, select couple of features, and try to find the execution paths for them in the code\n3. [ ] If feature tests are available, run them locally, Select 2 features (from tests), and follow their executin paths in the code\n4. [ ] You can keep notes for any important part of a feature\u0027s execution path using CodeTour for easier navigation\n\n\n## Why?\nOnce you have run the application, try to play around with it, to discover by yourself its functionality and its features.\n\n\nNow it\u0027s time to open the code and try to find the **Execution Paths** for some features i.e. how they work. \n\n\nIt\u0027s always a good idea to document your findings so you can create some **Tours** (using CodeTour), and adding the steps for a feature and your notes to reuse it as a point of reference in the future.\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Functional Overview\n- [ ] Map some Features with their Execution Paths"
    },
    {
      "title": "Git Log",
      "description": "# Git Log\n\n## Tasks\n\n1. [ ] Take a quick look to the history of the project, through the Git log (look for authors and commit frequency)\n2. [ ] Try to identify patterns and conventions on git commit messages\n3. [ ] Try to identify branching strategy and naming conventions\n4. [ ] Try to find a couple of features and take a quick look on them\n5. [ ] Read the commit messages up to 2-3 months ago\n6. [ ] Look on the open branches (names), currently under development\n\n\n## Why?\nAfter you have played around with the application, and have identified how some features are implemented, you should next go and take a quick look at the Git Log.\n\n\nA famous quote goes like this: *Those that fail to learn from history are destined to repeat it*.\n\nIf you look into the history of a project you may come up with some very useful findings:\n- the main contributors\n- the frequency of commits\n- commit messages patterns\n- the git workflow that is being used by the project\n- the branching strategy and naming conventions\n- context of a Pull Request for a specific feature\n\n\nIt is higly recommended to read the commit messages for at least the past 2-3 months, in order to identify what has been recently changed or implemented and by who.\n\n\nLastly, take a look at the open branches, by just reading their names, to take an idea of what is currently in-progress.\n\n\n## Takeways\n\nBefore proceeding to the next step, make sure you understood the key takeaways:\n- [ ] Authors (people with ofter commits)\n- [ ] Commit message patterns\n- [ ] Git workflow and branch naming conventions\n- [ ] Recent changes/features\n- [ ] Current changes/features under development"
    },
    {
      "title": "Overview Completed! Now what?",
      "description": "# Overview Completed! Now what?\n\n### Congratulations on completing this onboarding process! ðŸŽ‰ ðŸŽ‰ ðŸŽ‰\n\nHere are a few things you can do next:\n- [ ] Re-run this Tour as many times as you wish and focus on Steps for which you don\u0027t feel much confident\n- [ ] Collect any questions or code parts for which you need assistance or further elaboration\n- [ ] Share your questions with a colleague and ask him to assist you\n- [ ] Run other Tours (if available) to dive into deeper details for any project\n\n**Important**: Last but not least, it is always good to share your feedback about this onboarding experience, so let your colleagues know whether you found this onboarding process **effective** or not in order to improve the onboarding experience of future colleagues."
    }
  ]
}